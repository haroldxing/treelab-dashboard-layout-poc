webpackHotUpdate_N_E("pages/demo",{

/***/ "./components/GridLayout/lib/build/ReactGridLayout.js":
/*!************************************************************!*\
  !*** ./components/GridLayout/lib/build/ReactGridLayout.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash.isequal */ \"./node_modules/lodash.isequal/index.js\"));\n\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"./node_modules/classnames/index.js\"));\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./components/GridLayout/lib/build/utils.js\");\n\nvar _calculateUtils = __webpack_require__(/*! ./calculateUtils */ \"./components/GridLayout/lib/build/calculateUtils.js\");\n\nvar _GridItem = _interopRequireDefault(__webpack_require__(/*! ./GridItem */ \"./components/GridLayout/lib/build/GridItem.js\"));\n\nvar _ReactGridLayoutPropTypes = _interopRequireDefault(__webpack_require__(/*! ./ReactGridLayoutPropTypes */ \"./components/GridLayout/lib/build/ReactGridLayoutPropTypes.js\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // End Types\n\n\nvar layoutClassName = \"react-grid-layout\";\nvar isFirefox = false; // Try...catch will protect from navigator not existing (e.g. node) or a bad implementation of navigator\n\ntry {\n  isFirefox = /firefox/i.test(navigator.userAgent);\n} catch (e) {\n  /* Ignore */\n}\n/**\n * A reactive, fluid grid layout with draggable, resizable components.\n */\n\n\nvar ReactGridLayout = /*#__PURE__*/function (_React$Component) {\n  _inherits(ReactGridLayout, _React$Component);\n\n  var _super = _createSuper(ReactGridLayout); // TODO publish internal ReactClass displayName transform\n  // Refactored to another module to make way for preval\n\n\n  function ReactGridLayout(props,\n  /*: Props*/\n  context\n  /*: any*/\n  ) {\n    /*: void*/\n    var _this;\n\n    _classCallCheck(this, ReactGridLayout);\n\n    _this = _super.call(this, props, context);\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      activeDrag: null,\n      layout: (0, _utils.synchronizeLayoutWithChildren)(_this.props.layout, _this.props.children, _this.props.cols, // Legacy support for verticalCompact: false\n      (0, _utils.compactType)(_this.props)),\n      mounted: false,\n      oldDragItem: null,\n      oldLayout: null,\n      oldResizeItem: null,\n      droppingDOMNode: null,\n      children: []\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"dragEnterCounter\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"onDragOver\", function (e\n    /*: DragOverEvent*/\n    ) {\n      // we should ignore events from layout's children in Firefox\n      // to avoid unpredictable jumping of a dropping placeholder\n      // FIXME remove this hack\n      if (isFirefox && e.nativeEvent.target.className.indexOf(layoutClassName) === -1) {\n        // without this Firefox will not allow drop if currently over droppingItem\n        e.preventDefault();\n        return false;\n      }\n\n      var _this$props = _this.props,\n          droppingItem = _this$props.droppingItem,\n          margin = _this$props.margin,\n          cols = _this$props.cols,\n          rowHeight = _this$props.rowHeight,\n          maxRows = _this$props.maxRows,\n          width = _this$props.width,\n          containerPadding = _this$props.containerPadding;\n      var layout = _this.state.layout; // This is relative to the DOM element that this event fired for.\n\n      var _e$nativeEvent = e.nativeEvent,\n          layerX = _e$nativeEvent.layerX,\n          layerY = _e$nativeEvent.layerY;\n      var droppingPosition = {\n        left: layerX,\n        top: layerY,\n        e: e\n      };\n\n      if (!_this.state.droppingDOMNode) {\n        var positionParams =\n        /*: PositionParams*/\n        {\n          cols: cols,\n          margin: margin,\n          maxRows: maxRows,\n          rowHeight: rowHeight,\n          containerWidth: width,\n          containerPadding: containerPadding || margin\n        };\n        var calculatedPosition = (0, _calculateUtils.calcXY)(positionParams, layerY, layerX, droppingItem.w, droppingItem.h);\n\n        _this.setState({\n          droppingDOMNode: /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            key: droppingItem.i\n          }),\n          droppingPosition: droppingPosition,\n          layout: [].concat(_toConsumableArray(layout), [_objectSpread(_objectSpread({}, droppingItem), {}, {\n            x: calculatedPosition.x,\n            y: calculatedPosition.y,\n            \"static\": false,\n            isDraggable: true\n          })])\n        });\n      } else if (_this.state.droppingPosition) {\n        var _this$state$droppingP = _this.state.droppingPosition,\n            left = _this$state$droppingP.left,\n            top = _this$state$droppingP.top;\n        var shouldUpdatePosition = left != layerX || top != layerY;\n\n        if (shouldUpdatePosition) {\n          _this.setState({\n            droppingPosition: droppingPosition\n          });\n        }\n      }\n\n      e.stopPropagation();\n      e.preventDefault();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"removeDroppingPlaceholder\", function () {\n      var _this$props2 = _this.props,\n          droppingItem = _this$props2.droppingItem,\n          cols = _this$props2.cols;\n      var layout = _this.state.layout;\n      var newLayout = (0, _utils.compact)(layout.filter(function (l) {\n        return l.i !== droppingItem.i;\n      }), (0, _utils.compactType)(_this.props), cols);\n\n      _this.setState({\n        layout: newLayout,\n        droppingDOMNode: null,\n        activeDrag: null,\n        droppingPosition: undefined\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onDragLeave\", function () {\n      _this.dragEnterCounter--; // onDragLeave can be triggered on each layout's child.\n      // But we know that count of dragEnter and dragLeave events\n      // will be balanced after leaving the layout's container\n      // so we can increase and decrease count of dragEnter and\n      // when it'll be equal to 0 we'll remove the placeholder\n\n      if (_this.dragEnterCounter === 0) {\n        _this.removeDroppingPlaceholder();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onDragEnter\", function () {\n      _this.dragEnterCounter++;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onDrop\", function (e\n    /*: Event*/\n    ) {\n      var droppingItem = _this.props.droppingItem;\n      var layout = _this.state.layout;\n      var item = layout.find(function (l) {\n        return l.i === droppingItem.i;\n      }); // reset dragEnter counter on drop\n\n      _this.dragEnterCounter = 0;\n\n      _this.removeDroppingPlaceholder();\n\n      _this.props.onDrop(layout, item, e);\n    });\n\n    (0, _utils.autoBindHandlers)(_assertThisInitialized(_this), [\"onDragStart\", \"onDrag\", \"onDragStop\", \"onResizeStart\", \"onResize\", \"onResizeStop\"]);\n    return _this;\n  }\n\n  _createClass(ReactGridLayout, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.setState({\n        mounted: true\n      }); // Possibly call back with layout on mount. This should be done after correcting the layout width\n      // to ensure we don't rerender with the wrong width.\n\n      this.onLayoutMaybeChanged(this.state.layout, this.props.layout);\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps,\n    /*: Props*/\n    nextState\n    /*: State*/\n    ) {\n      return (// NOTE: this is almost always unequal. Therefore the only way to get better performance\n        // from SCU is if the user intentionally memoizes children. If they do, and they can\n        // handle changes properly, performance will increase.\n        this.props.children !== nextProps.children || !(0, _utils.fastRGLPropsEqual)(this.props, nextProps, _lodash[\"default\"]) || this.state.activeDrag !== nextState.activeDrag || this.state.mounted !== nextState.mounted || this.state.droppingPosition !== nextState.droppingPosition\n      );\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps,\n    /*: Props*/\n    prevState\n    /*: State*/\n    ) {\n      if (!this.state.activeDrag) {\n        var newLayout = this.state.layout;\n        var oldLayout = prevState.layout;\n        this.onLayoutMaybeChanged(newLayout, oldLayout);\n      }\n    }\n    /**\n     * Calculates a pixel value for the container.\n     * @return {String} Container height in pixels.\n     */\n\n  }, {\n    key: \"containerHeight\",\n    value: function containerHeight() {\n      if (!this.props.autoSize) return;\n      var nbRow = (0, _utils.bottom)(this.state.layout);\n      var containerPaddingY = this.props.containerPadding ? this.props.containerPadding[1] : this.props.margin[1];\n      return nbRow * this.props.rowHeight + (nbRow - 1) * this.props.margin[1] + containerPaddingY * 2 + \"px\";\n    }\n    /**\n     * When dragging starts\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n\n  }, {\n    key: \"onDragStart\",\n    value: function onDragStart(i,\n    /*: string*/\n    x,\n    /*: number*/\n    y,\n    /*: number*/\n    _ref) {\n      var e = _ref.e,\n          node = _ref.node;\n      var layout = this.state.layout;\n      var l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n      this.setState({\n        oldDragItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: this.state.layout\n      });\n      return this.props.onDragStart(layout, l, l, null, e, node);\n    }\n    /**\n     * Each drag movement create a new dragelement and move the element to the dragged location\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n\n  }, {\n    key: \"onDrag\",\n    value: function onDrag(i,\n    /*: string*/\n    x,\n    /*: number*/\n    y,\n    /*: number*/\n    _ref2) {\n      var e = _ref2.e,\n          node = _ref2.node;\n      var oldDragItem = this.state.oldDragItem;\n      var layout = this.state.layout;\n      var cols = this.props.cols;\n      var l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return; // Create placeholder (display only)\n\n      var placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        placeholder: true,\n        i: i\n      }; // Move the element to the dragged location.\n\n      var isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, this.props.preventCollision, (0, _utils.compactType)(this.props), cols);\n      this.props.onDrag(layout, oldDragItem, l, placeholder, e, node);\n      this.setState({\n        layout: (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    }\n    /**\n     * When dragging stops, figure out which position the element is closest to and update its x and y.\n     * @param  {String} i Index of the child.\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n\n  }, {\n    key: \"onDragStop\",\n    value: function onDragStop(i,\n    /*: string*/\n    x,\n    /*: number*/\n    y,\n    /*: number*/\n    _ref3) {\n      var e = _ref3.e,\n          node = _ref3.node;\n      if (!this.state.activeDrag) return;\n      var oldDragItem = this.state.oldDragItem;\n      var layout = this.state.layout;\n      var _this$props3 = this.props,\n          cols = _this$props3.cols,\n          preventCollision = _this$props3.preventCollision;\n      var l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return; // Move the element here\n\n      var isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols);\n      this.props.onDragStop(layout, oldDragItem, l, null, e, node); // Set state\n\n      var newLayout = (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      var oldLayout = this.state.oldLayout;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldDragItem: null,\n        oldLayout: null\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    }\n  }, {\n    key: \"onLayoutMaybeChanged\",\n    value: function onLayoutMaybeChanged(newLayout,\n    /*: Layout*/\n    oldLayout\n    /*: ?Layout*/\n    ) {\n      if (!oldLayout) oldLayout = this.state.layout;\n\n      if (!(0, _lodash[\"default\"])(oldLayout, newLayout)) {\n        this.props.onLayoutChange(newLayout);\n      }\n    }\n  }, {\n    key: \"onResizeStart\",\n    value: function onResizeStart(i,\n    /*: string*/\n    w,\n    /*: number*/\n    h,\n    /*: number*/\n    _ref4) {\n      var e = _ref4.e,\n          node = _ref4.node;\n      var layout = this.state.layout;\n      var l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n      this.setState({\n        oldResizeItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: this.state.layout\n      });\n      this.props.onResizeStart(layout, l, l, null, e, node);\n    }\n  }, {\n    key: \"onResize\",\n    value: function onResize(i,\n    /*: string*/\n    w,\n    /*: number*/\n    h,\n    /*: number*/\n    _ref5) {\n      var e = _ref5.e,\n          node = _ref5.node;\n      var _this$state = this.state,\n          layout = _this$state.layout,\n          oldResizeItem = _this$state.oldResizeItem;\n      var _this$props4 = this.props,\n          cols = _this$props4.cols,\n          preventCollision = _this$props4.preventCollision;\n      var l =\n      /*: ?LayoutItem*/\n      (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return; // Something like quad tree should be used\n      // to find collisions faster\n\n      var hasCollisions;\n\n      if (preventCollision) {\n        var collisions = (0, _utils.getAllCollisions)(layout, _objectSpread(_objectSpread({}, l), {}, {\n          w: w,\n          h: h\n        })).filter(function (layoutItem) {\n          return layoutItem.i !== l.i;\n        });\n        hasCollisions = collisions.length > 0; // If we're colliding, we need adjust the placeholder.\n\n        if (hasCollisions) {\n          // adjust w && h to maximum allowed space\n          var leastX = Infinity,\n              leastY = Infinity;\n          collisions.forEach(function (layoutItem) {\n            if (layoutItem.x > l.x) leastX = Math.min(leastX, layoutItem.x);\n            if (layoutItem.y > l.y) leastY = Math.min(leastY, layoutItem.y);\n          });\n          if (Number.isFinite(leastX)) l.w = leastX - l.x;\n          if (Number.isFinite(leastY)) l.h = leastY - l.y;\n        }\n      }\n\n      if (!hasCollisions) {\n        // Set new width and height.\n        l.w = w;\n        l.h = h;\n      } // Create placeholder element (display only)\n\n\n      var placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        \"static\": true,\n        i: i\n      };\n      this.props.onResize(layout, oldResizeItem, l, placeholder, e, node); // Re-compact the layout and set the drag placeholder.\n\n      this.setState({\n        layout: (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    }\n  }, {\n    key: \"onResizeStop\",\n    value: function onResizeStop(i,\n    /*: string*/\n    w,\n    /*: number*/\n    h,\n    /*: number*/\n    _ref6) {\n      var e = _ref6.e,\n          node = _ref6.node;\n      var _this$state2 = this.state,\n          layout = _this$state2.layout,\n          oldResizeItem = _this$state2.oldResizeItem;\n      var cols = this.props.cols;\n      var l = (0, _utils.getLayoutItem)(layout, i);\n      this.props.onResizeStop(layout, oldResizeItem, l, null, e, node); // Set state\n\n      var newLayout = (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      var oldLayout = this.state.oldLayout;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldResizeItem: null,\n        oldLayout: null\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    }\n    /**\n     * Create a placeholder object.\n     * @return {Element} Placeholder div.\n     */\n\n  }, {\n    key: \"placeholder\",\n    value: function placeholder()\n    /*: ?ReactElement<any>*/\n    {\n      var activeDrag = this.state.activeDrag;\n      if (!activeDrag) return null;\n      var _this$props5 = this.props,\n          width = _this$props5.width,\n          cols = _this$props5.cols,\n          margin = _this$props5.margin,\n          containerPadding = _this$props5.containerPadding,\n          rowHeight = _this$props5.rowHeight,\n          maxRows = _this$props5.maxRows,\n          useCSSTransforms = _this$props5.useCSSTransforms,\n          transformScale = _this$props5.transformScale; // {...this.state.activeDrag} is pretty slow, actually\n\n      return /*#__PURE__*/_react[\"default\"].createElement(_GridItem[\"default\"], {\n        w: activeDrag.w,\n        h: activeDrag.h,\n        x: activeDrag.x,\n        y: activeDrag.y,\n        i: activeDrag.i,\n        className: \"react-grid-placeholder\",\n        containerWidth: width,\n        cols: cols,\n        margin: margin,\n        containerPadding: containerPadding || margin,\n        maxRows: maxRows,\n        rowHeight: rowHeight,\n        isDraggable: false,\n        isResizable: false,\n        isBounded: false,\n        useCSSTransforms: useCSSTransforms,\n        transformScale: transformScale\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", null));\n    }\n    /**\n     * Given a grid item, set its style attributes & surround in a <Draggable>.\n     * @param  {Element} child React element.\n     * @return {Element}       Element wrapped in draggable and properly placed.\n     */\n\n  }, {\n    key: \"processGridItem\",\n    value: function processGridItem(child,\n    /*: ReactElement<any>*/\n    isDroppingItem\n    /*: boolean*/\n    )\n    /*: ?ReactElement<any>*/\n    {\n      if (!child || !child.key) return;\n      var l = (0, _utils.getLayoutItem)(this.state.layout, String(child.key));\n      if (!l) return null;\n      var _this$props6 = this.props,\n          width = _this$props6.width,\n          cols = _this$props6.cols,\n          margin = _this$props6.margin,\n          containerPadding = _this$props6.containerPadding,\n          rowHeight = _this$props6.rowHeight,\n          maxRows = _this$props6.maxRows,\n          isDraggable = _this$props6.isDraggable,\n          isResizable = _this$props6.isResizable,\n          isBounded = _this$props6.isBounded,\n          useCSSTransforms = _this$props6.useCSSTransforms,\n          transformScale = _this$props6.transformScale,\n          draggableCancel = _this$props6.draggableCancel,\n          draggableHandle = _this$props6.draggableHandle,\n          resizeHandles = _this$props6.resizeHandles,\n          resizeHandle = _this$props6.resizeHandle;\n      var _this$state3 = this.state,\n          mounted = _this$state3.mounted,\n          droppingPosition = _this$state3.droppingPosition; // Determine user manipulations possible.\n      // If an item is static, it can't be manipulated by default.\n      // Any properties defined directly on the grid item will take precedence.\n\n      var draggable = typeof l.isDraggable === \"boolean\" ? l.isDraggable : !l[\"static\"] && isDraggable;\n      var resizable = typeof l.isResizable === \"boolean\" ? l.isResizable : !l[\"static\"] && isResizable;\n      var resizeHandlesOptions = l.resizeHandles || resizeHandles; // isBounded set on child if set on parent, and child is not explicitly false\n\n      var bounded = draggable && isBounded && l.isBounded !== false;\n      return /*#__PURE__*/_react[\"default\"].createElement(_GridItem[\"default\"], {\n        containerWidth: width,\n        cols: cols,\n        margin: margin,\n        containerPadding: containerPadding || margin,\n        maxRows: maxRows,\n        rowHeight: rowHeight,\n        cancel: draggableCancel,\n        handle: draggableHandle,\n        onDragStop: this.onDragStop,\n        onDragStart: this.onDragStart,\n        onDrag: this.onDrag,\n        onResizeStart: this.onResizeStart,\n        onResize: this.onResize,\n        onResizeStop: this.onResizeStop,\n        isDraggable: draggable,\n        isResizable: resizable,\n        isBounded: bounded,\n        useCSSTransforms: useCSSTransforms && mounted,\n        usePercentages: !mounted,\n        transformScale: transformScale,\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        i: l.i,\n        minH: l.minH,\n        minW: l.minW,\n        maxH: l.maxH,\n        maxW: l.maxW,\n        \"static\": l[\"static\"],\n        droppingPosition: isDroppingItem ? droppingPosition : undefined,\n        resizeHandles: resizeHandlesOptions,\n        resizeHandle: resizeHandle\n      }, child);\n    } // Called while dragging an element. Part of browser native drag/drop API.\n    // Native event target might be the layout itself, or an element within the layout.\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props7 = this.props,\n          className = _this$props7.className,\n          style = _this$props7.style,\n          isDroppable = _this$props7.isDroppable,\n          innerRef = _this$props7.innerRef;\n      var mergedClassName = (0, _classnames[\"default\"])(layoutClassName, className);\n\n      var mergedStyle = _objectSpread({\n        height: this.containerHeight()\n      }, style);\n\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        ref: innerRef,\n        className: mergedClassName,\n        style: mergedStyle,\n        onDrop: isDroppable ? this.onDrop : _utils.noop,\n        onDragLeave: isDroppable ? this.onDragLeave : _utils.noop,\n        onDragEnter: isDroppable ? this.onDragEnter : _utils.noop,\n        onDragOver: isDroppable ? this.onDragOver : _utils.noop\n      }, _react[\"default\"].Children.map(this.props.children, function (child) {\n        return _this2.processGridItem(child);\n      }), isDroppable && this.state.droppingDOMNode && this.processGridItem(this.state.droppingDOMNode, true), this.placeholder());\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps,\n    /*: Props*/\n    prevState\n    /*: State*/\n    ) {\n      var newLayoutBase;\n\n      if (prevState.activeDrag) {\n        return null;\n      } // Legacy support for compactType\n      // Allow parent to set layout directly.\n\n\n      if (!(0, _lodash[\"default\"])(nextProps.layout, prevState.propsLayout) || nextProps.compactType !== prevState.compactType || !(0, _lodash[\"default\"])(nextProps.layout, prevState.layout) && nextProps.layout.length === prevState.layout.length) {\n        newLayoutBase = nextProps.layout;\n      } else if (!(0, _utils.childrenEqual)(nextProps.children, prevState.children)) {\n        // If children change, also regenerate the layout. Use our state\n        // as the base in case because it may be more up to date than\n        // what is in props.\n        newLayoutBase = prevState.layout;\n      } // We need to regenerate the layout.\n\n\n      if (newLayoutBase) {\n        var newLayout = (0, _utils.synchronizeLayoutWithChildren)(newLayoutBase, nextProps.children, nextProps.cols, (0, _utils.compactType)(nextProps));\n        return {\n          layout: newLayout,\n          // We need to save these props to state for using\n          // getDerivedStateFromProps instead of componentDidMount (in which we would get extra rerender)\n          compactType: nextProps.compactType,\n          children: nextProps.children,\n          propsLayout: nextProps.layout\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return ReactGridLayout;\n}(_react[\"default\"].Component);\n\nexports[\"default\"] = ReactGridLayout;\n\n_defineProperty(ReactGridLayout, \"displayName\", \"ReactGridLayout\");\n\n_defineProperty(ReactGridLayout, \"propTypes\", _ReactGridLayoutPropTypes[\"default\"]);\n\n_defineProperty(ReactGridLayout, \"defaultProps\", {\n  autoSize: true,\n  cols: 12,\n  className: \"\",\n  style: {},\n  draggableHandle: \"\",\n  draggableCancel: \"\",\n  containerPadding: null,\n  rowHeight: 150,\n  maxRows: Infinity,\n  // infinite vertical growth\n  layout: [],\n  margin: [10, 10],\n  isBounded: false,\n  isDraggable: true,\n  isResizable: true,\n  isDroppable: false,\n  useCSSTransforms: true,\n  transformScale: 1,\n  verticalCompact: true,\n  compactType: \"vertical\",\n  preventCollision: false,\n  droppingItem: {\n    i: \"__dropping-elem__\",\n    h: 1,\n    w: 1\n  },\n  resizeHandles: [\"se\"],\n  onLayoutChange: _utils.noop,\n  onDragStart: _utils.noop,\n  onDrag: _utils.noop,\n  onDragStop: _utils.noop,\n  onResizeStart: _utils.noop,\n  onResize: _utils.noop,\n  onResizeStop: _utils.noop,\n  onDrop: _utils.noop\n});\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/next/dist/compiled/webpack/module.js */ \"./node_modules/next/dist/compiled/webpack/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9HcmlkTGF5b3V0L2xpYi9idWlsZC9SZWFjdEdyaWRMYXlvdXQuanM/OGRlNSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2xvZGFzaCIsIl9jbGFzc25hbWVzIiwiX3V0aWxzIiwiX2NhbGN1bGF0ZVV0aWxzIiwiX0dyaWRJdGVtIiwiX1JlYWN0R3JpZExheW91dFByb3BUeXBlcyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfdHlwZW9mIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiZm9yRWFjaCIsImtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIlR5cGVFcnJvciIsIm8iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwiaXRlciIsImlzQXJyYXkiLCJsZW4iLCJhcnIyIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfY3JlYXRlU3VwZXIiLCJEZXJpdmVkIiwiaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfY3JlYXRlU3VwZXJJbnRlcm5hbCIsIlN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwicmVzdWx0IiwiTmV3VGFyZ2V0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsInNoYW0iLCJQcm94eSIsIkRhdGUiLCJlIiwiZ2V0UHJvdG90eXBlT2YiLCJsYXlvdXRDbGFzc05hbWUiLCJpc0ZpcmVmb3giLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJSZWFjdEdyaWRMYXlvdXQiLCJfUmVhY3QkQ29tcG9uZW50IiwiX3N1cGVyIiwiY29udGV4dCIsIl90aGlzIiwiYWN0aXZlRHJhZyIsImxheW91dCIsInN5bmNocm9uaXplTGF5b3V0V2l0aENoaWxkcmVuIiwiY2hpbGRyZW4iLCJjb2xzIiwiY29tcGFjdFR5cGUiLCJtb3VudGVkIiwib2xkRHJhZ0l0ZW0iLCJvbGRMYXlvdXQiLCJvbGRSZXNpemVJdGVtIiwiZHJvcHBpbmdET01Ob2RlIiwibmF0aXZlRXZlbnQiLCJjbGFzc05hbWUiLCJpbmRleE9mIiwicHJldmVudERlZmF1bHQiLCJfdGhpcyRwcm9wcyIsImRyb3BwaW5nSXRlbSIsIm1hcmdpbiIsInJvd0hlaWdodCIsIm1heFJvd3MiLCJ3aWR0aCIsImNvbnRhaW5lclBhZGRpbmciLCJzdGF0ZSIsIl9lJG5hdGl2ZUV2ZW50IiwibGF5ZXJYIiwibGF5ZXJZIiwiZHJvcHBpbmdQb3NpdGlvbiIsImxlZnQiLCJ0b3AiLCJwb3NpdGlvblBhcmFtcyIsImNvbnRhaW5lcldpZHRoIiwiY2FsY3VsYXRlZFBvc2l0aW9uIiwiY2FsY1hZIiwidyIsImgiLCJzZXRTdGF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJjb25jYXQiLCJ4IiwieSIsImlzRHJhZ2dhYmxlIiwiX3RoaXMkc3RhdGUkZHJvcHBpbmdQIiwic2hvdWxkVXBkYXRlUG9zaXRpb24iLCJzdG9wUHJvcGFnYXRpb24iLCJfdGhpcyRwcm9wczIiLCJuZXdMYXlvdXQiLCJjb21wYWN0IiwibCIsInVuZGVmaW5lZCIsImRyYWdFbnRlckNvdW50ZXIiLCJyZW1vdmVEcm9wcGluZ1BsYWNlaG9sZGVyIiwiaXRlbSIsImZpbmQiLCJvbkRyb3AiLCJhdXRvQmluZEhhbmRsZXJzIiwiY29tcG9uZW50RGlkTW91bnQiLCJvbkxheW91dE1heWJlQ2hhbmdlZCIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsIm5leHRQcm9wcyIsIm5leHRTdGF0ZSIsImZhc3RSR0xQcm9wc0VxdWFsIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwicHJldlN0YXRlIiwiY29udGFpbmVySGVpZ2h0IiwiYXV0b1NpemUiLCJuYlJvdyIsImJvdHRvbSIsImNvbnRhaW5lclBhZGRpbmdZIiwib25EcmFnU3RhcnQiLCJfcmVmIiwibm9kZSIsImdldExheW91dEl0ZW0iLCJjbG9uZUxheW91dEl0ZW0iLCJvbkRyYWciLCJfcmVmMiIsInBsYWNlaG9sZGVyIiwiaXNVc2VyQWN0aW9uIiwibW92ZUVsZW1lbnQiLCJwcmV2ZW50Q29sbGlzaW9uIiwib25EcmFnU3RvcCIsIl9yZWYzIiwiX3RoaXMkcHJvcHMzIiwib25MYXlvdXRDaGFuZ2UiLCJvblJlc2l6ZVN0YXJ0IiwiX3JlZjQiLCJvblJlc2l6ZSIsIl9yZWY1IiwiX3RoaXMkc3RhdGUiLCJfdGhpcyRwcm9wczQiLCJoYXNDb2xsaXNpb25zIiwiY29sbGlzaW9ucyIsImdldEFsbENvbGxpc2lvbnMiLCJsYXlvdXRJdGVtIiwibGVhc3RYIiwiSW5maW5pdHkiLCJsZWFzdFkiLCJNYXRoIiwibWluIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJvblJlc2l6ZVN0b3AiLCJfcmVmNiIsIl90aGlzJHN0YXRlMiIsIl90aGlzJHByb3BzNSIsInVzZUNTU1RyYW5zZm9ybXMiLCJ0cmFuc2Zvcm1TY2FsZSIsImlzUmVzaXphYmxlIiwiaXNCb3VuZGVkIiwicHJvY2Vzc0dyaWRJdGVtIiwiY2hpbGQiLCJpc0Ryb3BwaW5nSXRlbSIsIlN0cmluZyIsIl90aGlzJHByb3BzNiIsImRyYWdnYWJsZUNhbmNlbCIsImRyYWdnYWJsZUhhbmRsZSIsInJlc2l6ZUhhbmRsZXMiLCJyZXNpemVIYW5kbGUiLCJfdGhpcyRzdGF0ZTMiLCJkcmFnZ2FibGUiLCJyZXNpemFibGUiLCJyZXNpemVIYW5kbGVzT3B0aW9ucyIsImJvdW5kZWQiLCJjYW5jZWwiLCJoYW5kbGUiLCJ1c2VQZXJjZW50YWdlcyIsIm1pbkgiLCJtaW5XIiwibWF4SCIsIm1heFciLCJyZW5kZXIiLCJfdGhpczIiLCJfdGhpcyRwcm9wczciLCJzdHlsZSIsImlzRHJvcHBhYmxlIiwiaW5uZXJSZWYiLCJtZXJnZWRDbGFzc05hbWUiLCJtZXJnZWRTdHlsZSIsImhlaWdodCIsInJlZiIsIm5vb3AiLCJvbkRyYWdMZWF2ZSIsIm9uRHJhZ0VudGVyIiwib25EcmFnT3ZlciIsIkNoaWxkcmVuIiwibWFwIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibmV3TGF5b3V0QmFzZSIsInByb3BzTGF5b3V0IiwiY2hpbGRyZW5FcXVhbCIsIkNvbXBvbmVudCIsInZlcnRpY2FsQ29tcGFjdCJdLCJtYXBwaW5ncyI6IkFBQUEsOENBQWE7O0FBRWJBLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMs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O0FBR1pELEtBQUMsRUFBRTtBQUhTLEdBdEJpQztBQTJCL0NtRixlQUFhLEVBQUUsQ0FBQyxJQUFELENBM0JnQztBQTRCL0NqQyxnQkFBYyxFQUFFM0wsTUFBTSxDQUFDb1AsSUE1QndCO0FBNkIvQ3ZFLGFBQVcsRUFBRTdLLE1BQU0sQ0FBQ29QLElBN0IyQjtBQThCL0NsRSxRQUFNLEVBQUVsTCxNQUFNLENBQUNvUCxJQTlCZ0M7QUErQi9DNUQsWUFBVSxFQUFFeEwsTUFBTSxDQUFDb1AsSUEvQjRCO0FBZ0MvQ3hELGVBQWEsRUFBRTVMLE1BQU0sQ0FBQ29QLElBaEN5QjtBQWlDL0N0RCxVQUFRLEVBQUU5TCxNQUFNLENBQUNvUCxJQWpDOEI7QUFrQy9DdkMsY0FBWSxFQUFFN00sTUFBTSxDQUFDb1AsSUFsQzBCO0FBbUMvQ3ZGLFFBQU0sRUFBRTdKLE1BQU0sQ0FBQ29QO0FBbkNnQyxDQUFsQyxDQUFmIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9HcmlkTGF5b3V0L2xpYi9idWlsZC9SZWFjdEdyaWRMYXlvdXQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlLFxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfbG9kYXNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoLmlzZXF1YWxcIikpO1xuXG52YXIgX2NsYXNzbmFtZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG52YXIgX2NhbGN1bGF0ZVV0aWxzID0gcmVxdWlyZShcIi4vY2FsY3VsYXRlVXRpbHNcIik7XG5cbnZhciBfR3JpZEl0ZW0gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0dyaWRJdGVtXCIpKTtcblxudmFyIF9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KFxuICByZXF1aXJlKFwiLi9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXNcIilcbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9O1xufVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiZcbiAgICAgICAgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmXG4gICAgICAgIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZVxuICAgICAgICA/IFwic3ltYm9sXCJcbiAgICAgICAgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpXG4gICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIChcbiAgICBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fFxuICAgIF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fFxuICAgIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8XG4gICAgX25vbkl0ZXJhYmxlU3ByZWFkKClcbiAgKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgIFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiXG4gICk7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKVxuICAgIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSlcbiAgICByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0sXG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICByZXN1bHQ7XG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgIFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcbiAgICA/IE9iamVjdC5nZXRQcm90b3R5cGVPZlxuICAgIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICAgIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8vIEVuZCBUeXBlc1xudmFyIGxheW91dENsYXNzTmFtZSA9IFwicmVhY3QtZ3JpZC1sYXlvdXRcIjtcbnZhciBpc0ZpcmVmb3ggPSBmYWxzZTsgLy8gVHJ5Li4uY2F0Y2ggd2lsbCBwcm90ZWN0IGZyb20gbmF2aWdhdG9yIG5vdCBleGlzdGluZyAoZS5nLiBub2RlKSBvciBhIGJhZCBpbXBsZW1lbnRhdGlvbiBvZiBuYXZpZ2F0b3JcblxudHJ5IHtcbiAgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufSBjYXRjaCAoZSkge1xuICAvKiBJZ25vcmUgKi9cbn1cbi8qKlxuICogQSByZWFjdGl2ZSwgZmx1aWQgZ3JpZCBsYXlvdXQgd2l0aCBkcmFnZ2FibGUsIHJlc2l6YWJsZSBjb21wb25lbnRzLlxuICovXG5cbnZhciBSZWFjdEdyaWRMYXlvdXQgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUmVhY3RHcmlkTGF5b3V0LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJlYWN0R3JpZExheW91dCk7XG5cbiAgLy8gVE9ETyBwdWJsaXNoIGludGVybmFsIFJlYWN0Q2xhc3MgZGlzcGxheU5hbWUgdHJhbnNmb3JtXG4gIC8vIFJlZmFjdG9yZWQgdG8gYW5vdGhlciBtb2R1bGUgdG8gbWFrZSB3YXkgZm9yIHByZXZhbFxuICBmdW5jdGlvbiBSZWFjdEdyaWRMYXlvdXQoXG4gICAgcHJvcHMsXG4gICAgLyo6IFByb3BzKi9cbiAgICBjb250ZXh0XG4gICAgLyo6IGFueSovXG4gICkge1xuICAgIC8qOiB2b2lkKi9cbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVhY3RHcmlkTGF5b3V0KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN0YXRlXCIsIHtcbiAgICAgIGFjdGl2ZURyYWc6IG51bGwsXG4gICAgICBsYXlvdXQ6ICgwLCBfdXRpbHMuc3luY2hyb25pemVMYXlvdXRXaXRoQ2hpbGRyZW4pKFxuICAgICAgICBfdGhpcy5wcm9wcy5sYXlvdXQsXG4gICAgICAgIF90aGlzLnByb3BzLmNoaWxkcmVuLFxuICAgICAgICBfdGhpcy5wcm9wcy5jb2xzLCAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgdmVydGljYWxDb21wYWN0OiBmYWxzZVxuICAgICAgICAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKShfdGhpcy5wcm9wcylcbiAgICAgICksXG4gICAgICBtb3VudGVkOiBmYWxzZSxcbiAgICAgIG9sZERyYWdJdGVtOiBudWxsLFxuICAgICAgb2xkTGF5b3V0OiBudWxsLFxuICAgICAgb2xkUmVzaXplSXRlbTogbnVsbCxcbiAgICAgIGRyb3BwaW5nRE9NTm9kZTogbnVsbCxcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJkcmFnRW50ZXJDb3VudGVyXCIsIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uRHJhZ092ZXJcIiwgZnVuY3Rpb24gKFxuICAgICAgZVxuICAgICAgLyo6IERyYWdPdmVyRXZlbnQqL1xuICAgICkge1xuICAgICAgLy8gd2Ugc2hvdWxkIGlnbm9yZSBldmVudHMgZnJvbSBsYXlvdXQncyBjaGlsZHJlbiBpbiBGaXJlZm94XG4gICAgICAvLyB0byBhdm9pZCB1bnByZWRpY3RhYmxlIGp1bXBpbmcgb2YgYSBkcm9wcGluZyBwbGFjZWhvbGRlclxuICAgICAgLy8gRklYTUUgcmVtb3ZlIHRoaXMgaGFja1xuICAgICAgaWYgKFxuICAgICAgICBpc0ZpcmVmb3ggJiZcbiAgICAgICAgZS5uYXRpdmVFdmVudC50YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YobGF5b3V0Q2xhc3NOYW1lKSA9PT0gLTFcbiAgICAgICkge1xuICAgICAgICAvLyB3aXRob3V0IHRoaXMgRmlyZWZveCB3aWxsIG5vdCBhbGxvdyBkcm9wIGlmIGN1cnJlbnRseSBvdmVyIGRyb3BwaW5nSXRlbVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgIGRyb3BwaW5nSXRlbSA9IF90aGlzJHByb3BzLmRyb3BwaW5nSXRlbSxcbiAgICAgICAgbWFyZ2luID0gX3RoaXMkcHJvcHMubWFyZ2luLFxuICAgICAgICBjb2xzID0gX3RoaXMkcHJvcHMuY29scyxcbiAgICAgICAgcm93SGVpZ2h0ID0gX3RoaXMkcHJvcHMucm93SGVpZ2h0LFxuICAgICAgICBtYXhSb3dzID0gX3RoaXMkcHJvcHMubWF4Um93cyxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wcy53aWR0aCxcbiAgICAgICAgY29udGFpbmVyUGFkZGluZyA9IF90aGlzJHByb3BzLmNvbnRhaW5lclBhZGRpbmc7XG4gICAgICB2YXIgbGF5b3V0ID0gX3RoaXMuc3RhdGUubGF5b3V0OyAvLyBUaGlzIGlzIHJlbGF0aXZlIHRvIHRoZSBET00gZWxlbWVudCB0aGF0IHRoaXMgZXZlbnQgZmlyZWQgZm9yLlxuXG4gICAgICB2YXIgX2UkbmF0aXZlRXZlbnQgPSBlLm5hdGl2ZUV2ZW50LFxuICAgICAgICBsYXllclggPSBfZSRuYXRpdmVFdmVudC5sYXllclgsXG4gICAgICAgIGxheWVyWSA9IF9lJG5hdGl2ZUV2ZW50LmxheWVyWTtcbiAgICAgIHZhciBkcm9wcGluZ1Bvc2l0aW9uID0ge1xuICAgICAgICBsZWZ0OiBsYXllclgsXG4gICAgICAgIHRvcDogbGF5ZXJZLFxuICAgICAgICBlOiBlLFxuICAgICAgfTtcblxuICAgICAgaWYgKCFfdGhpcy5zdGF0ZS5kcm9wcGluZ0RPTU5vZGUpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uUGFyYW1zID1cbiAgICAgICAgICAvKjogUG9zaXRpb25QYXJhbXMqL1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbHM6IGNvbHMsXG4gICAgICAgICAgICBtYXJnaW46IG1hcmdpbixcbiAgICAgICAgICAgIG1heFJvd3M6IG1heFJvd3MsXG4gICAgICAgICAgICByb3dIZWlnaHQ6IHJvd0hlaWdodCxcbiAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGNvbnRhaW5lclBhZGRpbmc6IGNvbnRhaW5lclBhZGRpbmcgfHwgbWFyZ2luLFxuICAgICAgICAgIH07XG4gICAgICAgIHZhciBjYWxjdWxhdGVkUG9zaXRpb24gPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNYWSkoXG4gICAgICAgICAgcG9zaXRpb25QYXJhbXMsXG4gICAgICAgICAgbGF5ZXJZLFxuICAgICAgICAgIGxheWVyWCxcbiAgICAgICAgICBkcm9wcGluZ0l0ZW0udyxcbiAgICAgICAgICBkcm9wcGluZ0l0ZW0uaFxuICAgICAgICApO1xuXG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBkcm9wcGluZ0RPTU5vZGU6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBrZXk6IGRyb3BwaW5nSXRlbS5pLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGRyb3BwaW5nUG9zaXRpb246IGRyb3BwaW5nUG9zaXRpb24sXG4gICAgICAgICAgbGF5b3V0OiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxheW91dCksIFtcbiAgICAgICAgICAgIF9vYmplY3RTcHJlYWQoXG4gICAgICAgICAgICAgIF9vYmplY3RTcHJlYWQoe30sIGRyb3BwaW5nSXRlbSksXG4gICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgeDogY2FsY3VsYXRlZFBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgeTogY2FsY3VsYXRlZFBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgc3RhdGljOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0RyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKF90aGlzLnN0YXRlLmRyb3BwaW5nUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzJHN0YXRlJGRyb3BwaW5nUCA9IF90aGlzLnN0YXRlLmRyb3BwaW5nUG9zaXRpb24sXG4gICAgICAgICAgbGVmdCA9IF90aGlzJHN0YXRlJGRyb3BwaW5nUC5sZWZ0LFxuICAgICAgICAgIHRvcCA9IF90aGlzJHN0YXRlJGRyb3BwaW5nUC50b3A7XG4gICAgICAgIHZhciBzaG91bGRVcGRhdGVQb3NpdGlvbiA9IGxlZnQgIT0gbGF5ZXJYIHx8IHRvcCAhPSBsYXllclk7XG5cbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZVBvc2l0aW9uKSB7XG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZHJvcHBpbmdQb3NpdGlvbjogZHJvcHBpbmdQb3NpdGlvbixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KFxuICAgICAgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksXG4gICAgICBcInJlbW92ZURyb3BwaW5nUGxhY2Vob2xkZXJcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzJHByb3BzMiA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGRyb3BwaW5nSXRlbSA9IF90aGlzJHByb3BzMi5kcm9wcGluZ0l0ZW0sXG4gICAgICAgICAgY29scyA9IF90aGlzJHByb3BzMi5jb2xzO1xuICAgICAgICB2YXIgbGF5b3V0ID0gX3RoaXMuc3RhdGUubGF5b3V0O1xuICAgICAgICB2YXIgbmV3TGF5b3V0ID0gKDAsIF91dGlscy5jb21wYWN0KShcbiAgICAgICAgICBsYXlvdXQuZmlsdGVyKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICByZXR1cm4gbC5pICE9PSBkcm9wcGluZ0l0ZW0uaTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKShfdGhpcy5wcm9wcyksXG4gICAgICAgICAgY29sc1xuICAgICAgICApO1xuXG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBsYXlvdXQ6IG5ld0xheW91dCxcbiAgICAgICAgICBkcm9wcGluZ0RPTU5vZGU6IG51bGwsXG4gICAgICAgICAgYWN0aXZlRHJhZzogbnVsbCxcbiAgICAgICAgICBkcm9wcGluZ1Bvc2l0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25EcmFnTGVhdmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuZHJhZ0VudGVyQ291bnRlci0tOyAvLyBvbkRyYWdMZWF2ZSBjYW4gYmUgdHJpZ2dlcmVkIG9uIGVhY2ggbGF5b3V0J3MgY2hpbGQuXG4gICAgICAvLyBCdXQgd2Uga25vdyB0aGF0IGNvdW50IG9mIGRyYWdFbnRlciBhbmQgZHJhZ0xlYXZlIGV2ZW50c1xuICAgICAgLy8gd2lsbCBiZSBiYWxhbmNlZCBhZnRlciBsZWF2aW5nIHRoZSBsYXlvdXQncyBjb250YWluZXJcbiAgICAgIC8vIHNvIHdlIGNhbiBpbmNyZWFzZSBhbmQgZGVjcmVhc2UgY291bnQgb2YgZHJhZ0VudGVyIGFuZFxuICAgICAgLy8gd2hlbiBpdCdsbCBiZSBlcXVhbCB0byAwIHdlJ2xsIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXJcblxuICAgICAgaWYgKF90aGlzLmRyYWdFbnRlckNvdW50ZXIgPT09IDApIHtcbiAgICAgICAgX3RoaXMucmVtb3ZlRHJvcHBpbmdQbGFjZWhvbGRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uRHJhZ0VudGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmRyYWdFbnRlckNvdW50ZXIrKztcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvbkRyb3BcIiwgZnVuY3Rpb24gKFxuICAgICAgZVxuICAgICAgLyo6IEV2ZW50Ki9cbiAgICApIHtcbiAgICAgIHZhciBkcm9wcGluZ0l0ZW0gPSBfdGhpcy5wcm9wcy5kcm9wcGluZ0l0ZW07XG4gICAgICB2YXIgbGF5b3V0ID0gX3RoaXMuc3RhdGUubGF5b3V0O1xuICAgICAgdmFyIGl0ZW0gPSBsYXlvdXQuZmluZChmdW5jdGlvbiAobCkge1xuICAgICAgICByZXR1cm4gbC5pID09PSBkcm9wcGluZ0l0ZW0uaTtcbiAgICAgIH0pOyAvLyByZXNldCBkcmFnRW50ZXIgY291bnRlciBvbiBkcm9wXG5cbiAgICAgIF90aGlzLmRyYWdFbnRlckNvdW50ZXIgPSAwO1xuXG4gICAgICBfdGhpcy5yZW1vdmVEcm9wcGluZ1BsYWNlaG9sZGVyKCk7XG5cbiAgICAgIF90aGlzLnByb3BzLm9uRHJvcChsYXlvdXQsIGl0ZW0sIGUpO1xuICAgIH0pO1xuXG4gICAgKDAsIF91dGlscy5hdXRvQmluZEhhbmRsZXJzKShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgW1xuICAgICAgXCJvbkRyYWdTdGFydFwiLFxuICAgICAgXCJvbkRyYWdcIixcbiAgICAgIFwib25EcmFnU3RvcFwiLFxuICAgICAgXCJvblJlc2l6ZVN0YXJ0XCIsXG4gICAgICBcIm9uUmVzaXplXCIsXG4gICAgICBcIm9uUmVzaXplU3RvcFwiLFxuICAgIF0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhcbiAgICBSZWFjdEdyaWRMYXlvdXQsXG4gICAgW1xuICAgICAge1xuICAgICAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgbW91bnRlZDogdHJ1ZSxcbiAgICAgICAgICB9KTsgLy8gUG9zc2libHkgY2FsbCBiYWNrIHdpdGggbGF5b3V0IG9uIG1vdW50LiBUaGlzIHNob3VsZCBiZSBkb25lIGFmdGVyIGNvcnJlY3RpbmcgdGhlIGxheW91dCB3aWR0aFxuICAgICAgICAgIC8vIHRvIGVuc3VyZSB3ZSBkb24ndCByZXJlbmRlciB3aXRoIHRoZSB3cm9uZyB3aWR0aC5cblxuICAgICAgICAgIHRoaXMub25MYXlvdXRNYXliZUNoYW5nZWQodGhpcy5zdGF0ZS5sYXlvdXQsIHRoaXMucHJvcHMubGF5b3V0KTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJzaG91bGRDb21wb25lbnRVcGRhdGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgLyo6IFByb3BzKi9cbiAgICAgICAgICBuZXh0U3RhdGVcbiAgICAgICAgICAvKjogU3RhdGUqL1xuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gTk9URTogdGhpcyBpcyBhbG1vc3QgYWx3YXlzIHVuZXF1YWwuIFRoZXJlZm9yZSB0aGUgb25seSB3YXkgdG8gZ2V0IGJldHRlciBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gZnJvbSBTQ1UgaXMgaWYgdGhlIHVzZXIgaW50ZW50aW9uYWxseSBtZW1vaXplcyBjaGlsZHJlbi4gSWYgdGhleSBkbywgYW5kIHRoZXkgY2FuXG4gICAgICAgICAgICAvLyBoYW5kbGUgY2hhbmdlcyBwcm9wZXJseSwgcGVyZm9ybWFuY2Ugd2lsbCBpbmNyZWFzZS5cbiAgICAgICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW4gIT09IG5leHRQcm9wcy5jaGlsZHJlbiB8fFxuICAgICAgICAgICAgISgwLCBfdXRpbHMuZmFzdFJHTFByb3BzRXF1YWwpKFxuICAgICAgICAgICAgICB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIF9sb2Rhc2guZGVmYXVsdFxuICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5hY3RpdmVEcmFnICE9PSBuZXh0U3RhdGUuYWN0aXZlRHJhZyB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5tb3VudGVkICE9PSBuZXh0U3RhdGUubW91bnRlZCB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5kcm9wcGluZ1Bvc2l0aW9uICE9PSBuZXh0U3RhdGUuZHJvcHBpbmdQb3NpdGlvblxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoXG4gICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgIC8qOiBQcm9wcyovXG4gICAgICAgICAgcHJldlN0YXRlXG4gICAgICAgICAgLyo6IFN0YXRlKi9cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmFjdGl2ZURyYWcpIHtcbiAgICAgICAgICAgIHZhciBuZXdMYXlvdXQgPSB0aGlzLnN0YXRlLmxheW91dDtcbiAgICAgICAgICAgIHZhciBvbGRMYXlvdXQgPSBwcmV2U3RhdGUubGF5b3V0O1xuICAgICAgICAgICAgdGhpcy5vbkxheW91dE1heWJlQ2hhbmdlZChuZXdMYXlvdXQsIG9sZExheW91dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlcyBhIHBpeGVsIHZhbHVlIGZvciB0aGUgY29udGFpbmVyLlxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IENvbnRhaW5lciBoZWlnaHQgaW4gcGl4ZWxzLlxuICAgICAgICAgKi9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJjb250YWluZXJIZWlnaHRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRhaW5lckhlaWdodCgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMucHJvcHMuYXV0b1NpemUpIHJldHVybjtcbiAgICAgICAgICB2YXIgbmJSb3cgPSAoMCwgX3V0aWxzLmJvdHRvbSkodGhpcy5zdGF0ZS5sYXlvdXQpO1xuICAgICAgICAgIHZhciBjb250YWluZXJQYWRkaW5nWSA9IHRoaXMucHJvcHMuY29udGFpbmVyUGFkZGluZ1xuICAgICAgICAgICAgPyB0aGlzLnByb3BzLmNvbnRhaW5lclBhZGRpbmdbMV1cbiAgICAgICAgICAgIDogdGhpcy5wcm9wcy5tYXJnaW5bMV07XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG5iUm93ICogdGhpcy5wcm9wcy5yb3dIZWlnaHQgK1xuICAgICAgICAgICAgKG5iUm93IC0gMSkgKiB0aGlzLnByb3BzLm1hcmdpblsxXSArXG4gICAgICAgICAgICBjb250YWluZXJQYWRkaW5nWSAqIDIgK1xuICAgICAgICAgICAgXCJweFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gZHJhZ2dpbmcgc3RhcnRzXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpIElkIG9mIHRoZSBjaGlsZFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geCBYIHBvc2l0aW9uIG9mIHRoZSBtb3ZlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgcG9zaXRpb24gb2YgdGhlIG1vdmVcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSBUaGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBUaGUgY3VycmVudCBkcmFnZ2luZyBET00gZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJvbkRyYWdTdGFydFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnU3RhcnQoXG4gICAgICAgICAgaSxcbiAgICAgICAgICAvKjogc3RyaW5nKi9cbiAgICAgICAgICB4LFxuICAgICAgICAgIC8qOiBudW1iZXIqL1xuICAgICAgICAgIHksXG4gICAgICAgICAgLyo6IG51bWJlciovXG4gICAgICAgICAgX3JlZlxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgZSA9IF9yZWYuZSxcbiAgICAgICAgICAgIG5vZGUgPSBfcmVmLm5vZGU7XG4gICAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuc3RhdGUubGF5b3V0O1xuICAgICAgICAgIHZhciBsID0gKDAsIF91dGlscy5nZXRMYXlvdXRJdGVtKShsYXlvdXQsIGkpO1xuICAgICAgICAgIGlmICghbCkgcmV0dXJuO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgb2xkRHJhZ0l0ZW06ICgwLCBfdXRpbHMuY2xvbmVMYXlvdXRJdGVtKShsKSxcbiAgICAgICAgICAgIG9sZExheW91dDogdGhpcy5zdGF0ZS5sYXlvdXQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMub25EcmFnU3RhcnQobGF5b3V0LCBsLCBsLCBudWxsLCBlLCBub2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVhY2ggZHJhZyBtb3ZlbWVudCBjcmVhdGUgYSBuZXcgZHJhZ2VsZW1lbnQgYW5kIG1vdmUgdGhlIGVsZW1lbnQgdG8gdGhlIGRyYWdnZWQgbG9jYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGkgSWQgb2YgdGhlIGNoaWxkXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9zaXRpb24gb2YgdGhlIG1vdmVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvbiBvZiB0aGUgbW92ZVxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIFRoZSBjdXJyZW50IGRyYWdnaW5nIERPTSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcIm9uRHJhZ1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnKFxuICAgICAgICAgIGksXG4gICAgICAgICAgLyo6IHN0cmluZyovXG4gICAgICAgICAgeCxcbiAgICAgICAgICAvKjogbnVtYmVyKi9cbiAgICAgICAgICB5LFxuICAgICAgICAgIC8qOiBudW1iZXIqL1xuICAgICAgICAgIF9yZWYyXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBlID0gX3JlZjIuZSxcbiAgICAgICAgICAgIG5vZGUgPSBfcmVmMi5ub2RlO1xuICAgICAgICAgIHZhciBvbGREcmFnSXRlbSA9IHRoaXMuc3RhdGUub2xkRHJhZ0l0ZW07XG4gICAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuc3RhdGUubGF5b3V0O1xuICAgICAgICAgIHZhciBjb2xzID0gdGhpcy5wcm9wcy5jb2xzO1xuICAgICAgICAgIHZhciBsID0gKDAsIF91dGlscy5nZXRMYXlvdXRJdGVtKShsYXlvdXQsIGkpO1xuICAgICAgICAgIGlmICghbCkgcmV0dXJuOyAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgKGRpc3BsYXkgb25seSlcblxuICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHtcbiAgICAgICAgICAgIHc6IGwudyxcbiAgICAgICAgICAgIGg6IGwuaCxcbiAgICAgICAgICAgIHg6IGwueCxcbiAgICAgICAgICAgIHk6IGwueSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiB0cnVlLFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICB9OyAvLyBNb3ZlIHRoZSBlbGVtZW50IHRvIHRoZSBkcmFnZ2VkIGxvY2F0aW9uLlxuXG4gICAgICAgICAgdmFyIGlzVXNlckFjdGlvbiA9IHRydWU7XG4gICAgICAgICAgbGF5b3V0ID0gKDAsIF91dGlscy5tb3ZlRWxlbWVudCkoXG4gICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICBpc1VzZXJBY3Rpb24sXG4gICAgICAgICAgICB0aGlzLnByb3BzLnByZXZlbnRDb2xsaXNpb24sXG4gICAgICAgICAgICAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKSh0aGlzLnByb3BzKSxcbiAgICAgICAgICAgIGNvbHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucHJvcHMub25EcmFnKGxheW91dCwgb2xkRHJhZ0l0ZW0sIGwsIHBsYWNlaG9sZGVyLCBlLCBub2RlKTtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGxheW91dDogKDAsIF91dGlscy5jb21wYWN0KShcbiAgICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgICAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKSh0aGlzLnByb3BzKSxcbiAgICAgICAgICAgICAgY29sc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGFjdGl2ZURyYWc6IHBsYWNlaG9sZGVyLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBkcmFnZ2luZyBzdG9wcywgZmlndXJlIG91dCB3aGljaCBwb3NpdGlvbiB0aGUgZWxlbWVudCBpcyBjbG9zZXN0IHRvIGFuZCB1cGRhdGUgaXRzIHggYW5kIHkuXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gaSBJbmRleCBvZiB0aGUgY2hpbGQuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9zaXRpb24gb2YgdGhlIG1vdmVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvbiBvZiB0aGUgbW92ZVxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIFRoZSBjdXJyZW50IGRyYWdnaW5nIERPTSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcIm9uRHJhZ1N0b3BcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZ1N0b3AoXG4gICAgICAgICAgaSxcbiAgICAgICAgICAvKjogc3RyaW5nKi9cbiAgICAgICAgICB4LFxuICAgICAgICAgIC8qOiBudW1iZXIqL1xuICAgICAgICAgIHksXG4gICAgICAgICAgLyo6IG51bWJlciovXG4gICAgICAgICAgX3JlZjNcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGUgPSBfcmVmMy5lLFxuICAgICAgICAgICAgbm9kZSA9IF9yZWYzLm5vZGU7XG4gICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmFjdGl2ZURyYWcpIHJldHVybjtcbiAgICAgICAgICB2YXIgb2xkRHJhZ0l0ZW0gPSB0aGlzLnN0YXRlLm9sZERyYWdJdGVtO1xuICAgICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLnN0YXRlLmxheW91dDtcbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGNvbHMgPSBfdGhpcyRwcm9wczMuY29scyxcbiAgICAgICAgICAgIHByZXZlbnRDb2xsaXNpb24gPSBfdGhpcyRwcm9wczMucHJldmVudENvbGxpc2lvbjtcbiAgICAgICAgICB2YXIgbCA9ICgwLCBfdXRpbHMuZ2V0TGF5b3V0SXRlbSkobGF5b3V0LCBpKTtcbiAgICAgICAgICBpZiAoIWwpIHJldHVybjsgLy8gTW92ZSB0aGUgZWxlbWVudCBoZXJlXG5cbiAgICAgICAgICB2YXIgaXNVc2VyQWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBsYXlvdXQgPSAoMCwgX3V0aWxzLm1vdmVFbGVtZW50KShcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIGlzVXNlckFjdGlvbixcbiAgICAgICAgICAgIHByZXZlbnRDb2xsaXNpb24sXG4gICAgICAgICAgICAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKSh0aGlzLnByb3BzKSxcbiAgICAgICAgICAgIGNvbHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucHJvcHMub25EcmFnU3RvcChsYXlvdXQsIG9sZERyYWdJdGVtLCBsLCBudWxsLCBlLCBub2RlKTsgLy8gU2V0IHN0YXRlXG5cbiAgICAgICAgICB2YXIgbmV3TGF5b3V0ID0gKDAsIF91dGlscy5jb21wYWN0KShcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKHRoaXMucHJvcHMpLFxuICAgICAgICAgICAgY29sc1xuICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIG9sZExheW91dCA9IHRoaXMuc3RhdGUub2xkTGF5b3V0O1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgYWN0aXZlRHJhZzogbnVsbCxcbiAgICAgICAgICAgIGxheW91dDogbmV3TGF5b3V0LFxuICAgICAgICAgICAgb2xkRHJhZ0l0ZW06IG51bGwsXG4gICAgICAgICAgICBvbGRMYXlvdXQ6IG51bGwsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5vbkxheW91dE1heWJlQ2hhbmdlZChuZXdMYXlvdXQsIG9sZExheW91dCk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IFwib25MYXlvdXRNYXliZUNoYW5nZWRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uTGF5b3V0TWF5YmVDaGFuZ2VkKFxuICAgICAgICAgIG5ld0xheW91dCxcbiAgICAgICAgICAvKjogTGF5b3V0Ki9cbiAgICAgICAgICBvbGRMYXlvdXRcbiAgICAgICAgICAvKjogP0xheW91dCovXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICghb2xkTGF5b3V0KSBvbGRMYXlvdXQgPSB0aGlzLnN0YXRlLmxheW91dDtcblxuICAgICAgICAgIGlmICghKDAsIF9sb2Rhc2guZGVmYXVsdCkob2xkTGF5b3V0LCBuZXdMYXlvdXQpKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uTGF5b3V0Q2hhbmdlKG5ld0xheW91dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcIm9uUmVzaXplU3RhcnRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVzaXplU3RhcnQoXG4gICAgICAgICAgaSxcbiAgICAgICAgICAvKjogc3RyaW5nKi9cbiAgICAgICAgICB3LFxuICAgICAgICAgIC8qOiBudW1iZXIqL1xuICAgICAgICAgIGgsXG4gICAgICAgICAgLyo6IG51bWJlciovXG4gICAgICAgICAgX3JlZjRcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGUgPSBfcmVmNC5lLFxuICAgICAgICAgICAgbm9kZSA9IF9yZWY0Lm5vZGU7XG4gICAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuc3RhdGUubGF5b3V0O1xuICAgICAgICAgIHZhciBsID0gKDAsIF91dGlscy5nZXRMYXlvdXRJdGVtKShsYXlvdXQsIGkpO1xuICAgICAgICAgIGlmICghbCkgcmV0dXJuO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgb2xkUmVzaXplSXRlbTogKDAsIF91dGlscy5jbG9uZUxheW91dEl0ZW0pKGwpLFxuICAgICAgICAgICAgb2xkTGF5b3V0OiB0aGlzLnN0YXRlLmxheW91dCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnByb3BzLm9uUmVzaXplU3RhcnQobGF5b3V0LCBsLCBsLCBudWxsLCBlLCBub2RlKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJvblJlc2l6ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25SZXNpemUoXG4gICAgICAgICAgaSxcbiAgICAgICAgICAvKjogc3RyaW5nKi9cbiAgICAgICAgICB3LFxuICAgICAgICAgIC8qOiBudW1iZXIqL1xuICAgICAgICAgIGgsXG4gICAgICAgICAgLyo6IG51bWJlciovXG4gICAgICAgICAgX3JlZjVcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGUgPSBfcmVmNS5lLFxuICAgICAgICAgICAgbm9kZSA9IF9yZWY1Lm5vZGU7XG4gICAgICAgICAgdmFyIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIGxheW91dCA9IF90aGlzJHN0YXRlLmxheW91dCxcbiAgICAgICAgICAgIG9sZFJlc2l6ZUl0ZW0gPSBfdGhpcyRzdGF0ZS5vbGRSZXNpemVJdGVtO1xuICAgICAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgY29scyA9IF90aGlzJHByb3BzNC5jb2xzLFxuICAgICAgICAgICAgcHJldmVudENvbGxpc2lvbiA9IF90aGlzJHByb3BzNC5wcmV2ZW50Q29sbGlzaW9uO1xuICAgICAgICAgIHZhciBsID1cbiAgICAgICAgICAgIC8qOiA/TGF5b3V0SXRlbSovXG4gICAgICAgICAgICAoMCwgX3V0aWxzLmdldExheW91dEl0ZW0pKGxheW91dCwgaSk7XG4gICAgICAgICAgaWYgKCFsKSByZXR1cm47IC8vIFNvbWV0aGluZyBsaWtlIHF1YWQgdHJlZSBzaG91bGQgYmUgdXNlZFxuICAgICAgICAgIC8vIHRvIGZpbmQgY29sbGlzaW9ucyBmYXN0ZXJcblxuICAgICAgICAgIHZhciBoYXNDb2xsaXNpb25zO1xuXG4gICAgICAgICAgaWYgKHByZXZlbnRDb2xsaXNpb24pIHtcbiAgICAgICAgICAgIHZhciBjb2xsaXNpb25zID0gKDAsIF91dGlscy5nZXRBbGxDb2xsaXNpb25zKShcbiAgICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgICBfb2JqZWN0U3ByZWFkKFxuICAgICAgICAgICAgICAgIF9vYmplY3RTcHJlYWQoe30sIGwpLFxuICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHc6IHcsXG4gICAgICAgICAgICAgICAgICBoOiBoLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKS5maWx0ZXIoZnVuY3Rpb24gKGxheW91dEl0ZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxheW91dEl0ZW0uaSAhPT0gbC5pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYXNDb2xsaXNpb25zID0gY29sbGlzaW9ucy5sZW5ndGggPiAwOyAvLyBJZiB3ZSdyZSBjb2xsaWRpbmcsIHdlIG5lZWQgYWRqdXN0IHRoZSBwbGFjZWhvbGRlci5cblxuICAgICAgICAgICAgaWYgKGhhc0NvbGxpc2lvbnMpIHtcbiAgICAgICAgICAgICAgLy8gYWRqdXN0IHcgJiYgaCB0byBtYXhpbXVtIGFsbG93ZWQgc3BhY2VcbiAgICAgICAgICAgICAgdmFyIGxlYXN0WCA9IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIGxlYXN0WSA9IEluZmluaXR5O1xuICAgICAgICAgICAgICBjb2xsaXNpb25zLmZvckVhY2goZnVuY3Rpb24gKGxheW91dEl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0SXRlbS54ID4gbC54KSBsZWFzdFggPSBNYXRoLm1pbihsZWFzdFgsIGxheW91dEl0ZW0ueCk7XG4gICAgICAgICAgICAgICAgaWYgKGxheW91dEl0ZW0ueSA+IGwueSkgbGVhc3RZID0gTWF0aC5taW4obGVhc3RZLCBsYXlvdXRJdGVtLnkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShsZWFzdFgpKSBsLncgPSBsZWFzdFggLSBsLng7XG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUobGVhc3RZKSkgbC5oID0gbGVhc3RZIC0gbC55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaGFzQ29sbGlzaW9ucykge1xuICAgICAgICAgICAgLy8gU2V0IG5ldyB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAgICAgICAgbC53ID0gdztcbiAgICAgICAgICAgIGwuaCA9IGg7XG4gICAgICAgICAgfSAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgZWxlbWVudCAoZGlzcGxheSBvbmx5KVxuXG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0ge1xuICAgICAgICAgICAgdzogbC53LFxuICAgICAgICAgICAgaDogbC5oLFxuICAgICAgICAgICAgeDogbC54LFxuICAgICAgICAgICAgeTogbC55LFxuICAgICAgICAgICAgc3RhdGljOiB0cnVlLFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMucHJvcHMub25SZXNpemUobGF5b3V0LCBvbGRSZXNpemVJdGVtLCBsLCBwbGFjZWhvbGRlciwgZSwgbm9kZSk7IC8vIFJlLWNvbXBhY3QgdGhlIGxheW91dCBhbmQgc2V0IHRoZSBkcmFnIHBsYWNlaG9sZGVyLlxuXG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBsYXlvdXQ6ICgwLCBfdXRpbHMuY29tcGFjdCkoXG4gICAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgICAgKDAsIF91dGlscy5jb21wYWN0VHlwZSkodGhpcy5wcm9wcyksXG4gICAgICAgICAgICAgIGNvbHNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBhY3RpdmVEcmFnOiBwbGFjZWhvbGRlcixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJvblJlc2l6ZVN0b3BcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVzaXplU3RvcChcbiAgICAgICAgICBpLFxuICAgICAgICAgIC8qOiBzdHJpbmcqL1xuICAgICAgICAgIHcsXG4gICAgICAgICAgLyo6IG51bWJlciovXG4gICAgICAgICAgaCxcbiAgICAgICAgICAvKjogbnVtYmVyKi9cbiAgICAgICAgICBfcmVmNlxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgZSA9IF9yZWY2LmUsXG4gICAgICAgICAgICBub2RlID0gX3JlZjYubm9kZTtcbiAgICAgICAgICB2YXIgX3RoaXMkc3RhdGUyID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIGxheW91dCA9IF90aGlzJHN0YXRlMi5sYXlvdXQsXG4gICAgICAgICAgICBvbGRSZXNpemVJdGVtID0gX3RoaXMkc3RhdGUyLm9sZFJlc2l6ZUl0ZW07XG4gICAgICAgICAgdmFyIGNvbHMgPSB0aGlzLnByb3BzLmNvbHM7XG4gICAgICAgICAgdmFyIGwgPSAoMCwgX3V0aWxzLmdldExheW91dEl0ZW0pKGxheW91dCwgaSk7XG4gICAgICAgICAgdGhpcy5wcm9wcy5vblJlc2l6ZVN0b3AobGF5b3V0LCBvbGRSZXNpemVJdGVtLCBsLCBudWxsLCBlLCBub2RlKTsgLy8gU2V0IHN0YXRlXG5cbiAgICAgICAgICB2YXIgbmV3TGF5b3V0ID0gKDAsIF91dGlscy5jb21wYWN0KShcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKHRoaXMucHJvcHMpLFxuICAgICAgICAgICAgY29sc1xuICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIG9sZExheW91dCA9IHRoaXMuc3RhdGUub2xkTGF5b3V0O1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgYWN0aXZlRHJhZzogbnVsbCxcbiAgICAgICAgICAgIGxheW91dDogbmV3TGF5b3V0LFxuICAgICAgICAgICAgb2xkUmVzaXplSXRlbTogbnVsbCxcbiAgICAgICAgICAgIG9sZExheW91dDogbnVsbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLm9uTGF5b3V0TWF5YmVDaGFuZ2VkKG5ld0xheW91dCwgb2xkTGF5b3V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIHBsYWNlaG9sZGVyIG9iamVjdC5cbiAgICAgICAgICogQHJldHVybiB7RWxlbWVudH0gUGxhY2Vob2xkZXIgZGl2LlxuICAgICAgICAgKi9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGxhY2Vob2xkZXIoKSAvKjogP1JlYWN0RWxlbWVudDxhbnk+Ki9cbiAgICAgICAge1xuICAgICAgICAgIHZhciBhY3RpdmVEcmFnID0gdGhpcy5zdGF0ZS5hY3RpdmVEcmFnO1xuICAgICAgICAgIGlmICghYWN0aXZlRHJhZykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNS53aWR0aCxcbiAgICAgICAgICAgIGNvbHMgPSBfdGhpcyRwcm9wczUuY29scyxcbiAgICAgICAgICAgIG1hcmdpbiA9IF90aGlzJHByb3BzNS5tYXJnaW4sXG4gICAgICAgICAgICBjb250YWluZXJQYWRkaW5nID0gX3RoaXMkcHJvcHM1LmNvbnRhaW5lclBhZGRpbmcsXG4gICAgICAgICAgICByb3dIZWlnaHQgPSBfdGhpcyRwcm9wczUucm93SGVpZ2h0LFxuICAgICAgICAgICAgbWF4Um93cyA9IF90aGlzJHByb3BzNS5tYXhSb3dzLFxuICAgICAgICAgICAgdXNlQ1NTVHJhbnNmb3JtcyA9IF90aGlzJHByb3BzNS51c2VDU1NUcmFuc2Zvcm1zLFxuICAgICAgICAgICAgdHJhbnNmb3JtU2NhbGUgPSBfdGhpcyRwcm9wczUudHJhbnNmb3JtU2NhbGU7IC8vIHsuLi50aGlzLnN0YXRlLmFjdGl2ZURyYWd9IGlzIHByZXR0eSBzbG93LCBhY3R1YWxseVxuXG4gICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIF9HcmlkSXRlbS5kZWZhdWx0LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB3OiBhY3RpdmVEcmFnLncsXG4gICAgICAgICAgICAgIGg6IGFjdGl2ZURyYWcuaCxcbiAgICAgICAgICAgICAgeDogYWN0aXZlRHJhZy54LFxuICAgICAgICAgICAgICB5OiBhY3RpdmVEcmFnLnksXG4gICAgICAgICAgICAgIGk6IGFjdGl2ZURyYWcuaSxcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJlYWN0LWdyaWQtcGxhY2Vob2xkZXJcIixcbiAgICAgICAgICAgICAgY29udGFpbmVyV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICBjb2xzOiBjb2xzLFxuICAgICAgICAgICAgICBtYXJnaW46IG1hcmdpbixcbiAgICAgICAgICAgICAgY29udGFpbmVyUGFkZGluZzogY29udGFpbmVyUGFkZGluZyB8fCBtYXJnaW4sXG4gICAgICAgICAgICAgIG1heFJvd3M6IG1heFJvd3MsXG4gICAgICAgICAgICAgIHJvd0hlaWdodDogcm93SGVpZ2h0LFxuICAgICAgICAgICAgICBpc0RyYWdnYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIGlzUmVzaXphYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgaXNCb3VuZGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgdXNlQ1NTVHJhbnNmb3JtczogdXNlQ1NTVHJhbnNmb3JtcyxcbiAgICAgICAgICAgICAgdHJhbnNmb3JtU2NhbGU6IHRyYW5zZm9ybVNjYWxlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIGdyaWQgaXRlbSwgc2V0IGl0cyBzdHlsZSBhdHRyaWJ1dGVzICYgc3Vycm91bmQgaW4gYSA8RHJhZ2dhYmxlPi5cbiAgICAgICAgICogQHBhcmFtICB7RWxlbWVudH0gY2hpbGQgUmVhY3QgZWxlbWVudC5cbiAgICAgICAgICogQHJldHVybiB7RWxlbWVudH0gICAgICAgRWxlbWVudCB3cmFwcGVkIGluIGRyYWdnYWJsZSBhbmQgcHJvcGVybHkgcGxhY2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogXCJwcm9jZXNzR3JpZEl0ZW1cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NHcmlkSXRlbShcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAvKjogUmVhY3RFbGVtZW50PGFueT4qL1xuICAgICAgICAgIGlzRHJvcHBpbmdJdGVtXG4gICAgICAgICAgLyo6IGJvb2xlYW4qL1xuICAgICAgICApIC8qOiA/UmVhY3RFbGVtZW50PGFueT4qL1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFjaGlsZCB8fCAhY2hpbGQua2V5KSByZXR1cm47XG4gICAgICAgICAgdmFyIGwgPSAoMCwgX3V0aWxzLmdldExheW91dEl0ZW0pKFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5sYXlvdXQsXG4gICAgICAgICAgICBTdHJpbmcoY2hpbGQua2V5KVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHM2ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM2LndpZHRoLFxuICAgICAgICAgICAgY29scyA9IF90aGlzJHByb3BzNi5jb2xzLFxuICAgICAgICAgICAgbWFyZ2luID0gX3RoaXMkcHJvcHM2Lm1hcmdpbixcbiAgICAgICAgICAgIGNvbnRhaW5lclBhZGRpbmcgPSBfdGhpcyRwcm9wczYuY29udGFpbmVyUGFkZGluZyxcbiAgICAgICAgICAgIHJvd0hlaWdodCA9IF90aGlzJHByb3BzNi5yb3dIZWlnaHQsXG4gICAgICAgICAgICBtYXhSb3dzID0gX3RoaXMkcHJvcHM2Lm1heFJvd3MsXG4gICAgICAgICAgICBpc0RyYWdnYWJsZSA9IF90aGlzJHByb3BzNi5pc0RyYWdnYWJsZSxcbiAgICAgICAgICAgIGlzUmVzaXphYmxlID0gX3RoaXMkcHJvcHM2LmlzUmVzaXphYmxlLFxuICAgICAgICAgICAgaXNCb3VuZGVkID0gX3RoaXMkcHJvcHM2LmlzQm91bmRlZCxcbiAgICAgICAgICAgIHVzZUNTU1RyYW5zZm9ybXMgPSBfdGhpcyRwcm9wczYudXNlQ1NTVHJhbnNmb3JtcyxcbiAgICAgICAgICAgIHRyYW5zZm9ybVNjYWxlID0gX3RoaXMkcHJvcHM2LnRyYW5zZm9ybVNjYWxlLFxuICAgICAgICAgICAgZHJhZ2dhYmxlQ2FuY2VsID0gX3RoaXMkcHJvcHM2LmRyYWdnYWJsZUNhbmNlbCxcbiAgICAgICAgICAgIGRyYWdnYWJsZUhhbmRsZSA9IF90aGlzJHByb3BzNi5kcmFnZ2FibGVIYW5kbGUsXG4gICAgICAgICAgICByZXNpemVIYW5kbGVzID0gX3RoaXMkcHJvcHM2LnJlc2l6ZUhhbmRsZXMsXG4gICAgICAgICAgICByZXNpemVIYW5kbGUgPSBfdGhpcyRwcm9wczYucmVzaXplSGFuZGxlO1xuICAgICAgICAgIHZhciBfdGhpcyRzdGF0ZTMgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgbW91bnRlZCA9IF90aGlzJHN0YXRlMy5tb3VudGVkLFxuICAgICAgICAgICAgZHJvcHBpbmdQb3NpdGlvbiA9IF90aGlzJHN0YXRlMy5kcm9wcGluZ1Bvc2l0aW9uOyAvLyBEZXRlcm1pbmUgdXNlciBtYW5pcHVsYXRpb25zIHBvc3NpYmxlLlxuICAgICAgICAgIC8vIElmIGFuIGl0ZW0gaXMgc3RhdGljLCBpdCBjYW4ndCBiZSBtYW5pcHVsYXRlZCBieSBkZWZhdWx0LlxuICAgICAgICAgIC8vIEFueSBwcm9wZXJ0aWVzIGRlZmluZWQgZGlyZWN0bHkgb24gdGhlIGdyaWQgaXRlbSB3aWxsIHRha2UgcHJlY2VkZW5jZS5cblxuICAgICAgICAgIHZhciBkcmFnZ2FibGUgPVxuICAgICAgICAgICAgdHlwZW9mIGwuaXNEcmFnZ2FibGUgPT09IFwiYm9vbGVhblwiXG4gICAgICAgICAgICAgID8gbC5pc0RyYWdnYWJsZVxuICAgICAgICAgICAgICA6ICFsLnN0YXRpYyAmJiBpc0RyYWdnYWJsZTtcbiAgICAgICAgICB2YXIgcmVzaXphYmxlID1cbiAgICAgICAgICAgIHR5cGVvZiBsLmlzUmVzaXphYmxlID09PSBcImJvb2xlYW5cIlxuICAgICAgICAgICAgICA/IGwuaXNSZXNpemFibGVcbiAgICAgICAgICAgICAgOiAhbC5zdGF0aWMgJiYgaXNSZXNpemFibGU7XG4gICAgICAgICAgdmFyIHJlc2l6ZUhhbmRsZXNPcHRpb25zID0gbC5yZXNpemVIYW5kbGVzIHx8IHJlc2l6ZUhhbmRsZXM7IC8vIGlzQm91bmRlZCBzZXQgb24gY2hpbGQgaWYgc2V0IG9uIHBhcmVudCwgYW5kIGNoaWxkIGlzIG5vdCBleHBsaWNpdGx5IGZhbHNlXG5cbiAgICAgICAgICB2YXIgYm91bmRlZCA9IGRyYWdnYWJsZSAmJiBpc0JvdW5kZWQgJiYgbC5pc0JvdW5kZWQgIT09IGZhbHNlO1xuICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBfR3JpZEl0ZW0uZGVmYXVsdCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29udGFpbmVyV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICBjb2xzOiBjb2xzLFxuICAgICAgICAgICAgICBtYXJnaW46IG1hcmdpbixcbiAgICAgICAgICAgICAgY29udGFpbmVyUGFkZGluZzogY29udGFpbmVyUGFkZGluZyB8fCBtYXJnaW4sXG4gICAgICAgICAgICAgIG1heFJvd3M6IG1heFJvd3MsXG4gICAgICAgICAgICAgIHJvd0hlaWdodDogcm93SGVpZ2h0LFxuICAgICAgICAgICAgICBjYW5jZWw6IGRyYWdnYWJsZUNhbmNlbCxcbiAgICAgICAgICAgICAgaGFuZGxlOiBkcmFnZ2FibGVIYW5kbGUsXG4gICAgICAgICAgICAgIG9uRHJhZ1N0b3A6IHRoaXMub25EcmFnU3RvcCxcbiAgICAgICAgICAgICAgb25EcmFnU3RhcnQ6IHRoaXMub25EcmFnU3RhcnQsXG4gICAgICAgICAgICAgIG9uRHJhZzogdGhpcy5vbkRyYWcsXG4gICAgICAgICAgICAgIG9uUmVzaXplU3RhcnQ6IHRoaXMub25SZXNpemVTdGFydCxcbiAgICAgICAgICAgICAgb25SZXNpemU6IHRoaXMub25SZXNpemUsXG4gICAgICAgICAgICAgIG9uUmVzaXplU3RvcDogdGhpcy5vblJlc2l6ZVN0b3AsXG4gICAgICAgICAgICAgIGlzRHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgICAgICAgICAgIGlzUmVzaXphYmxlOiByZXNpemFibGUsXG4gICAgICAgICAgICAgIGlzQm91bmRlZDogYm91bmRlZCxcbiAgICAgICAgICAgICAgdXNlQ1NTVHJhbnNmb3JtczogdXNlQ1NTVHJhbnNmb3JtcyAmJiBtb3VudGVkLFxuICAgICAgICAgICAgICB1c2VQZXJjZW50YWdlczogIW1vdW50ZWQsXG4gICAgICAgICAgICAgIHRyYW5zZm9ybVNjYWxlOiB0cmFuc2Zvcm1TY2FsZSxcbiAgICAgICAgICAgICAgdzogbC53LFxuICAgICAgICAgICAgICBoOiBsLmgsXG4gICAgICAgICAgICAgIHg6IGwueCxcbiAgICAgICAgICAgICAgeTogbC55LFxuICAgICAgICAgICAgICBpOiBsLmksXG4gICAgICAgICAgICAgIG1pbkg6IGwubWluSCxcbiAgICAgICAgICAgICAgbWluVzogbC5taW5XLFxuICAgICAgICAgICAgICBtYXhIOiBsLm1heEgsXG4gICAgICAgICAgICAgIG1heFc6IGwubWF4VyxcbiAgICAgICAgICAgICAgc3RhdGljOiBsLnN0YXRpYyxcbiAgICAgICAgICAgICAgZHJvcHBpbmdQb3NpdGlvbjogaXNEcm9wcGluZ0l0ZW0gPyBkcm9wcGluZ1Bvc2l0aW9uIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICByZXNpemVIYW5kbGVzOiByZXNpemVIYW5kbGVzT3B0aW9ucyxcbiAgICAgICAgICAgICAgcmVzaXplSGFuZGxlOiByZXNpemVIYW5kbGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICB9LCAvLyBDYWxsZWQgd2hpbGUgZHJhZ2dpbmcgYW4gZWxlbWVudC4gUGFydCBvZiBicm93c2VyIG5hdGl2ZSBkcmFnL2Ryb3AgQVBJLlxuICAgICAgICAvLyBOYXRpdmUgZXZlbnQgdGFyZ2V0IG1pZ2h0IGJlIHRoZSBsYXlvdXQgaXRzZWxmLCBvciBhbiBlbGVtZW50IHdpdGhpbiB0aGUgbGF5b3V0LlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcInJlbmRlclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgdmFyIF90aGlzJHByb3BzNyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczcuY2xhc3NOYW1lLFxuICAgICAgICAgICAgc3R5bGUgPSBfdGhpcyRwcm9wczcuc3R5bGUsXG4gICAgICAgICAgICBpc0Ryb3BwYWJsZSA9IF90aGlzJHByb3BzNy5pc0Ryb3BwYWJsZSxcbiAgICAgICAgICAgIGlubmVyUmVmID0gX3RoaXMkcHJvcHM3LmlubmVyUmVmO1xuICAgICAgICAgIHZhciBtZXJnZWRDbGFzc05hbWUgPSAoMCwgX2NsYXNzbmFtZXMuZGVmYXVsdCkoXG4gICAgICAgICAgICBsYXlvdXRDbGFzc05hbWUsXG4gICAgICAgICAgICBjbGFzc05hbWVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgdmFyIG1lcmdlZFN0eWxlID0gX29iamVjdFNwcmVhZChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmNvbnRhaW5lckhlaWdodCgpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0eWxlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgICAgICAgICBjbGFzc05hbWU6IG1lcmdlZENsYXNzTmFtZSxcbiAgICAgICAgICAgICAgc3R5bGU6IG1lcmdlZFN0eWxlLFxuICAgICAgICAgICAgICBvbkRyb3A6IGlzRHJvcHBhYmxlID8gdGhpcy5vbkRyb3AgOiBfdXRpbHMubm9vcCxcbiAgICAgICAgICAgICAgb25EcmFnTGVhdmU6IGlzRHJvcHBhYmxlID8gdGhpcy5vbkRyYWdMZWF2ZSA6IF91dGlscy5ub29wLFxuICAgICAgICAgICAgICBvbkRyYWdFbnRlcjogaXNEcm9wcGFibGUgPyB0aGlzLm9uRHJhZ0VudGVyIDogX3V0aWxzLm5vb3AsXG4gICAgICAgICAgICAgIG9uRHJhZ092ZXI6IGlzRHJvcHBhYmxlID8gdGhpcy5vbkRyYWdPdmVyIDogX3V0aWxzLm5vb3AsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ubWFwKHRoaXMucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLnByb2Nlc3NHcmlkSXRlbShjaGlsZCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGlzRHJvcHBhYmxlICYmXG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUuZHJvcHBpbmdET01Ob2RlICYmXG4gICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0dyaWRJdGVtKHRoaXMuc3RhdGUuZHJvcHBpbmdET01Ob2RlLCB0cnVlKSxcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIoKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIF0sXG4gICAgW1xuICAgICAge1xuICAgICAgICBrZXk6IFwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgIC8qOiBQcm9wcyovXG4gICAgICAgICAgcHJldlN0YXRlXG4gICAgICAgICAgLyo6IFN0YXRlKi9cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIG5ld0xheW91dEJhc2U7XG5cbiAgICAgICAgICBpZiAocHJldlN0YXRlLmFjdGl2ZURyYWcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gLy8gTGVnYWN5IHN1cHBvcnQgZm9yIGNvbXBhY3RUeXBlXG4gICAgICAgICAgLy8gQWxsb3cgcGFyZW50IHRvIHNldCBsYXlvdXQgZGlyZWN0bHkuXG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKDAsIF9sb2Rhc2guZGVmYXVsdCkobmV4dFByb3BzLmxheW91dCwgcHJldlN0YXRlLnByb3BzTGF5b3V0KSB8fFxuICAgICAgICAgICAgbmV4dFByb3BzLmNvbXBhY3RUeXBlICE9PSBwcmV2U3RhdGUuY29tcGFjdFR5cGUgfHxcbiAgICAgICAgICAgICghKDAsIF9sb2Rhc2guZGVmYXVsdCkobmV4dFByb3BzLmxheW91dCwgcHJldlN0YXRlLmxheW91dCkgJiZcbiAgICAgICAgICAgICAgbmV4dFByb3BzLmxheW91dC5sZW5ndGggPT09IHByZXZTdGF0ZS5sYXlvdXQubGVuZ3RoKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbmV3TGF5b3V0QmFzZSA9IG5leHRQcm9wcy5sYXlvdXQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICEoMCwgX3V0aWxzLmNoaWxkcmVuRXF1YWwpKG5leHRQcm9wcy5jaGlsZHJlbiwgcHJldlN0YXRlLmNoaWxkcmVuKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gSWYgY2hpbGRyZW4gY2hhbmdlLCBhbHNvIHJlZ2VuZXJhdGUgdGhlIGxheW91dC4gVXNlIG91ciBzdGF0ZVxuICAgICAgICAgICAgLy8gYXMgdGhlIGJhc2UgaW4gY2FzZSBiZWNhdXNlIGl0IG1heSBiZSBtb3JlIHVwIHRvIGRhdGUgdGhhblxuICAgICAgICAgICAgLy8gd2hhdCBpcyBpbiBwcm9wcy5cbiAgICAgICAgICAgIG5ld0xheW91dEJhc2UgPSBwcmV2U3RhdGUubGF5b3V0O1xuICAgICAgICAgIH0gLy8gV2UgbmVlZCB0byByZWdlbmVyYXRlIHRoZSBsYXlvdXQuXG5cbiAgICAgICAgICBpZiAobmV3TGF5b3V0QmFzZSkge1xuICAgICAgICAgICAgdmFyIG5ld0xheW91dCA9ICgwLCBfdXRpbHMuc3luY2hyb25pemVMYXlvdXRXaXRoQ2hpbGRyZW4pKFxuICAgICAgICAgICAgICBuZXdMYXlvdXRCYXNlLFxuICAgICAgICAgICAgICBuZXh0UHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIG5leHRQcm9wcy5jb2xzLFxuICAgICAgICAgICAgICAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKShuZXh0UHJvcHMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbGF5b3V0OiBuZXdMYXlvdXQsXG4gICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc2F2ZSB0aGVzZSBwcm9wcyB0byBzdGF0ZSBmb3IgdXNpbmdcbiAgICAgICAgICAgICAgLy8gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIGluc3RlYWQgb2YgY29tcG9uZW50RGlkTW91bnQgKGluIHdoaWNoIHdlIHdvdWxkIGdldCBleHRyYSByZXJlbmRlcilcbiAgICAgICAgICAgICAgY29tcGFjdFR5cGU6IG5leHRQcm9wcy5jb21wYWN0VHlwZSxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IG5leHRQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcHJvcHNMYXlvdXQ6IG5leHRQcm9wcy5sYXlvdXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICBdXG4gICk7XG5cbiAgcmV0dXJuIFJlYWN0R3JpZExheW91dDtcbn0pKF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJlYWN0R3JpZExheW91dDtcblxuX2RlZmluZVByb3BlcnR5KFJlYWN0R3JpZExheW91dCwgXCJkaXNwbGF5TmFtZVwiLCBcIlJlYWN0R3JpZExheW91dFwiKTtcblxuX2RlZmluZVByb3BlcnR5KFxuICBSZWFjdEdyaWRMYXlvdXQsXG4gIFwicHJvcFR5cGVzXCIsXG4gIF9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXMuZGVmYXVsdFxuKTtcblxuX2RlZmluZVByb3BlcnR5KFJlYWN0R3JpZExheW91dCwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBhdXRvU2l6ZTogdHJ1ZSxcbiAgY29sczogMTIsXG4gIGNsYXNzTmFtZTogXCJcIixcbiAgc3R5bGU6IHt9LFxuICBkcmFnZ2FibGVIYW5kbGU6IFwiXCIsXG4gIGRyYWdnYWJsZUNhbmNlbDogXCJcIixcbiAgY29udGFpbmVyUGFkZGluZzogbnVsbCxcbiAgcm93SGVpZ2h0OiAxNTAsXG4gIG1heFJvd3M6IEluZmluaXR5LFxuICAvLyBpbmZpbml0ZSB2ZXJ0aWNhbCBncm93dGhcbiAgbGF5b3V0OiBbXSxcbiAgbWFyZ2luOiBbMTAsIDEwXSxcbiAgaXNCb3VuZGVkOiBmYWxzZSxcbiAgaXNEcmFnZ2FibGU6IHRydWUsXG4gIGlzUmVzaXphYmxlOiB0cnVlLFxuICBpc0Ryb3BwYWJsZTogZmFsc2UsXG4gIHVzZUNTU1RyYW5zZm9ybXM6IHRydWUsXG4gIHRyYW5zZm9ybVNjYWxlOiAxLFxuICB2ZXJ0aWNhbENvbXBhY3Q6IHRydWUsXG4gIGNvbXBhY3RUeXBlOiBcInZlcnRpY2FsXCIsXG4gIHByZXZlbnRDb2xsaXNpb246IGZhbHNlLFxuICBkcm9wcGluZ0l0ZW06IHtcbiAgICBpOiBcIl9fZHJvcHBpbmctZWxlbV9fXCIsXG4gICAgaDogMSxcbiAgICB3OiAxLFxuICB9LFxuICByZXNpemVIYW5kbGVzOiBbXCJzZVwiXSxcbiAgb25MYXlvdXRDaGFuZ2U6IF91dGlscy5ub29wLFxuICBvbkRyYWdTdGFydDogX3V0aWxzLm5vb3AsXG4gIG9uRHJhZzogX3V0aWxzLm5vb3AsXG4gIG9uRHJhZ1N0b3A6IF91dGlscy5ub29wLFxuICBvblJlc2l6ZVN0YXJ0OiBfdXRpbHMubm9vcCxcbiAgb25SZXNpemU6IF91dGlscy5ub29wLFxuICBvblJlc2l6ZVN0b3A6IF91dGlscy5ub29wLFxuICBvbkRyb3A6IF91dGlscy5ub29wLFxufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/GridLayout/lib/build/ReactGridLayout.js\n");

/***/ })

})